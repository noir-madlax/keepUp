# æ ¸å¿ƒä»£ç å®ç°æ–‡æ¡£

## Supabase Edge Functions

### æ–‡ä»¶ç»“æ„
```
supabase/
â””â”€â”€ functions/
    â”œâ”€â”€ scrape-site/
    â”‚   â”œâ”€â”€ index.ts          # é€šç”¨æŠ“å–å™¨
    â”‚   â”œâ”€â”€ scraper-engine.ts # æŠ“å–å¼•æ“
    â”‚   â””â”€â”€ config-parser.ts  # é…ç½®è§£æå™¨
    â””â”€â”€ scrape-all/
        â””â”€â”€ index.ts          # æ‰¹é‡è§¦å‘å™¨
```

### 1. é€šç”¨æŠ“å–å™¨ (scrape-site/index.ts)

```typescript
// supabase/functions/scrape-site/index.ts
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { chromium } from "https://deno.land/x/playwright@1.40.0/mod.ts";

/**
 * é€šç”¨ç½‘ç«™æŠ“å–Edge Function
 * åŠŸèƒ½ï¼šæ ¹æ®æ•°æ®åº“é…ç½®è‡ªåŠ¨æŠ“å–ç½‘ç«™æ•°æ®
 * æ”¯æŒï¼šæ‰‹åŠ¨è§¦å‘ + è‡ªåŠ¨å®šæ—¶ä»»åŠ¡
 */
serve(async (req) => {
  const startTime = Date.now();
  
  try {
    // 1. è§£æè¯·æ±‚å‚æ•°
    const { site_slug, validate_only = false } = await req.json();
    
    if (!site_slug) {
      return new Response(
        JSON.stringify({ error: "Missing site_slug parameter" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    // 2. åˆå§‹åŒ–Supabaseå®¢æˆ·ç«¯
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // 3. ä»æ•°æ®åº“è·å–ç½‘ç«™é…ç½®
    const { data: site, error: siteError } = await supabase
      .from("keep_monitor_sites")
      .select("*")
      .eq("slug", site_slug)
      .single();

    if (siteError || !site) {
      return new Response(
        JSON.stringify({ error: "Site not found" }),
        { status: 404, headers: { "Content-Type": "application/json" } }
      );
    }

    // 4. è·å–Cookieæ•°æ®
    const { data: cookieData, error: cookieError } = await supabase
      .from("keep_monitor_cookies")
      .select("*")
      .eq("site_slug", site_slug)
      .single();

    if (cookieError || !cookieData) {
      return new Response(
        JSON.stringify({ error: "Cookies not found" }),
        { status: 404, headers: { "Content-Type": "application/json" } }
      );
    }

    // 5. å¯åŠ¨æµè§ˆå™¨
    const browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ]
    });

    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
    });

    const page = await context.newPage();

    // 6. è®¾ç½®Cookie
    const cookies = cookieData.cookies.map((c: any) => ({
      name: c.name,
      value: c.value,
      domain: c.domain,
      path: c.path || '/',
      expires: c.expirationDate ? c.expirationDate : undefined,
      httpOnly: c.httpOnly || false,
      secure: c.secure || false,
      sameSite: c.sameSite === 'unspecified' ? 'lax' : c.sameSite
    }));

    await context.addCookies(cookies);

    let extractedData = {};
    let screenshotBuffer: Buffer | null = null;
    let cookieValid = true;
    let errorMessage: string | null = null;

    try {
      // 7. æ‰§è¡Œé…ç½®ä¸­çš„æ­¥éª¤
      const config = site.scraper_config;
      
      for (const step of config.steps) {
        switch (step.action) {
          case 'navigate':
            await page.goto(step.url, {
              waitUntil: step.wait_for || 'networkidle',
              timeout: step.timeout || 30000
            });
            break;

          case 'wait':
            await page.waitForSelector(step.selector, {
              timeout: step.timeout || 10000
            });
            break;

          case 'extract':
            const value = await extractData(page, step);
            extractedData[step.name] = value;
            break;

          case 'screenshot':
            screenshotBuffer = await page.screenshot({
              type: 'png',
              fullPage: step.full_page || false
            });
            break;

          case 'click':
            await page.click(step.selector);
            break;

          case 'type':
            await page.fill(step.selector, step.value);
            break;
        }
      }

      // 8. éªŒè¯Cookieæœ‰æ•ˆæ€§
      if (config.validation && config.validation.cookie_check) {
        const checkSelector = config.validation.cookie_check.selector;
        const shouldExist = config.validation.cookie_check.should_exist !== false;
        
        const elementExists = await page.locator(checkSelector).count() > 0;
        cookieValid = elementExists === shouldExist;
      }

    } catch (err) {
      errorMessage = err.message;
      cookieValid = false;
    } finally {
      await browser.close();
    }

    const duration = Date.now() - startTime;

    // 9. ä¸Šä¼ æˆªå›¾åˆ°Storageï¼ˆå¦‚æœæœ‰ï¼‰
    let screenshotUrl: string | null = null;
    if (screenshotBuffer) {
      const filename = `${site_slug}/latest.png`;
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('monitor-screenshots')
        .upload(filename, screenshotBuffer, {
          contentType: 'image/png',
          upsert: true // è¦†ç›–æ—§æ–‡ä»¶
        });

      if (!uploadError) {
        const { data: publicUrlData } = supabase.storage
          .from('monitor-screenshots')
          .getPublicUrl(filename);
        screenshotUrl = publicUrlData.publicUrl;
      }
    }

    // 10. æ·»åŠ æŠ“å–æ—¶é—´æˆ³
    extractedData['scraped_at'] = new Date().toISOString();

    // 11. ä¿å­˜è®°å½•åˆ°æ•°æ®åº“
    const status = cookieValid ? 'success' : 'cookie_invalid';
    const { error: recordError } = await supabase
      .from('keep_monitor_records')
      .insert({
        site_slug,
        data: extractedData,
        screenshot_url: screenshotUrl,
        scrape_duration: duration,
        status,
        error_message: errorMessage,
        trigger_source: 'auto' // å¯ä»¥é€šè¿‡å‚æ•°ä¼ å…¥
      });

    // 12. æ›´æ–°Cookieæœ‰æ•ˆæ€§çŠ¶æ€
    if (!cookieValid) {
      await supabase
        .from('keep_monitor_cookies')
        .update({
          is_valid: false,
          last_validated_at: new Date().toISOString(),
          validation_error: errorMessage || 'Cookie validation failed'
        })
        .eq('site_slug', site_slug);
    } else {
      await supabase
        .from('keep_monitor_cookies')
        .update({
          is_valid: true,
          last_validated_at: new Date().toISOString(),
          validation_error: null
        })
        .eq('site_slug', site_slug);
    }

    // 13. è¿”å›ç»“æœ
    return new Response(
      JSON.stringify({
        success: cookieValid,
        status,
        data: extractedData,
        screenshot_url: screenshotUrl,
        duration,
        cookie_valid: cookieValid,
        error: errorMessage
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );

  } catch (error) {
    console.error("Error in scrape-site:", error);
    return new Response(
      JSON.stringify({
        error: error.message,
        stack: error.stack
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
});

/**
 * æå–æ•°æ®çš„è¾…åŠ©å‡½æ•°
 */
async function extractData(page: any, step: any): Promise<any> {
  const { selector, extract_type, regex_pattern, regex_group, transform } = step;

  let rawValue: string;

  if (extract_type === 'regex' || regex_pattern) {
    // æ­£åˆ™æå–
    const textContent = await page.textContent('body');
    const pattern = new RegExp(selector.replace('text=/', '').replace('/', ''));
    const match = textContent.match(pattern);
    rawValue = match && match[regex_group || 1] ? match[regex_group || 1] : null;
  } else {
    // æ™®é€šselectoræå–
    const element = await page.locator(selector).first();
    rawValue = await element.textContent();
  }

  // æ•°æ®è½¬æ¢
  if (rawValue && transform) {
    switch (transform) {
      case 'float':
        return parseFloat(rawValue);
      case 'int':
        return parseInt(rawValue, 10);
      case 'date':
        return new Date(rawValue).toISOString();
      default:
        return rawValue;
    }
  }

  return rawValue;
}
```

### 2. æ‰¹é‡è§¦å‘å™¨ (scrape-all/index.ts)

```typescript
// supabase/functions/scrape-all/index.ts
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/**
 * æ‰¹é‡æŠ“å–è§¦å‘å™¨
 * ç”¨é€”ï¼šè¢«Vercel Cronè°ƒç”¨ï¼Œè§¦å‘æ‰€æœ‰å¯ç”¨ç½‘ç«™çš„æŠ“å–
 */
serve(async (req) => {
  try {
    // 1. åˆå§‹åŒ–Supabaseå®¢æˆ·ç«¯
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // 2. è·å–æ‰€æœ‰å¯ç”¨çš„ç½‘ç«™
    const { data: sites, error } = await supabase
      .from("keep_monitor_sites")
      .select("slug, name")
      .eq("is_active", true)
      .order("display_order");

    if (error) {
      throw error;
    }

    // 3. å¹¶è¡Œè°ƒç”¨scrape-site
    const promises = sites.map((site) => 
      fetch(`${supabaseUrl}/functions/v1/scrape-site`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          site_slug: site.slug,
          trigger_source: "auto"
        })
      })
      .then(res => res.json())
      .then(data => ({ site: site.name, ...data }))
      .catch(err => ({ site: site.name, error: err.message }))
    );

    // 4. ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    const results = await Promise.allSettled(promises);

    // 5. ç»Ÿè®¡ç»“æœ
    const summary = {
      total: sites.length,
      success: 0,
      failed: 0,
      details: results.map(r => r.status === 'fulfilled' ? r.value : r.reason)
    };

    results.forEach(r => {
      if (r.status === 'fulfilled' && r.value.success) {
        summary.success++;
      } else {
        summary.failed++;
      }
    });

    // 6. è¿”å›ç»“æœ
    return new Response(
      JSON.stringify(summary),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );

  } catch (error) {
    console.error("Error in scrape-all:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
});
```

## Vercel API Route

### æ–‡ä»¶ï¼šapi/cron/scrape-monitor.ts

```typescript
import type { VercelRequest, VercelResponse } from '@vercel/node';

/**
 * Vercel Cron Jobåè°ƒå™¨
 * ä½œç”¨ï¼šæ¥æ”¶Vercel Cronçš„è°ƒç”¨ï¼Œè½¬å‘åˆ°Supabase Edge Function
 * å®‰å…¨ï¼šéªŒè¯CRON_SECRETé˜²æ­¢æœªæˆæƒè®¿é—®
 */
export default async function handler(
  req: VercelRequest,
  res: VercelResponse
) {
  // 1. éªŒè¯è¯·æ±‚æ¥è‡ªVercel Cron
  const authHeader = req.headers.authorization || '';
  const expectedAuth = `Bearer ${process.env.CRON_SECRET}`;

  if (authHeader !== expectedAuth) {
    console.error('Unauthorized cron access attempt');
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    // 2. è®°å½•æ‰§è¡Œæ—¥å¿—
    console.log('[Cron] Starting scrape-monitor job at', new Date().toISOString());

    // 3. è°ƒç”¨Supabase Edge Function
    const supabaseUrl = process.env.VITE_SUPABASE_URL!;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

    const response = await fetch(
      `${supabaseUrl}/functions/v1/scrape-all`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${supabaseKey}`,
          'Content-Type': 'application/json'
        }
      }
    );

    const data = await response.json();

    // 4. è®°å½•ç»“æœ
    console.log('[Cron] Scrape-monitor job completed:', data);

    // 5. è¿”å›ç»“æœ
    return res.status(200).json({
      success: true,
      timestamp: new Date().toISOString(),
      result: data
    });

  } catch (error) {
    console.error('[Cron] Error in scrape-monitor job:', error);
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
}
```

## å‰ç«¯æ ¸å¿ƒä»£ç 

### 1. MonitorView.vue

```vue
<template>
  <div class="monitor-view">
    <!-- æ ‡é¢˜å’Œåˆ·æ–°æŒ‰é’® -->
    <div class="monitor-header">
      <h1>è´¹ç”¨ç›‘æ§é¢æ¿</h1>
      <button 
        @click="refreshAll" 
        :disabled="isRefreshing"
        class="refresh-all-btn"
      >
        <span v-if="!isRefreshing">ğŸ”„ å…¨éƒ¨åˆ·æ–°</span>
        <span v-else>â³ åˆ·æ–°ä¸­...</span>
      </button>
    </div>

    <!-- å¡ç‰‡ç½‘æ ¼ -->
    <div class="monitor-grid">
      <MonitorCard
        v-for="site in sites"
        :key="site.slug"
        :site="site"
        :latest-record="getLatestRecord(site.slug)"
        :cookie-status="getCookieStatus(site.slug)"
        @refresh="refreshSite(site.slug)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { supabase } from '@/supabaseClient';
import MonitorCard from '@/components/MonitorCard.vue';

// çŠ¶æ€ç®¡ç†
const sites = ref([]);
const records = ref([]);
const cookies = ref([]);
const isRefreshing = ref(false);

// åŠ è½½æ•°æ®
onMounted(async () => {
  await loadSites();
  await loadRecords();
  await loadCookies();
});

// åŠ è½½ç½‘ç«™é…ç½®
async function loadSites() {
  const { data, error } = await supabase
    .from('keep_monitor_sites')
    .select('*')
    .eq('is_active', true)
    .order('display_order');

  if (!error) {
    sites.value = data;
  }
}

// åŠ è½½æœ€æ–°è®°å½•
async function loadRecords() {
  const { data, error } = await supabase
    .from('keep_monitor_records')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(100);

  if (!error) {
    records.value = data;
  }
}

// åŠ è½½CookieçŠ¶æ€
async function loadCookies() {
  const { data, error } = await supabase
    .from('keep_monitor_cookies')
    .select('site_slug, is_valid, last_validated_at');

  if (!error) {
    cookies.value = data;
  }
}

// è·å–ç½‘ç«™çš„æœ€æ–°è®°å½•
function getLatestRecord(siteSlug: string) {
  return records.value.find(r => r.site_slug === siteSlug);
}

// è·å–CookieçŠ¶æ€
function getCookieStatus(siteSlug: string) {
  return cookies.value.find(c => c.site_slug === siteSlug);
}

// åˆ·æ–°å•ä¸ªç½‘ç«™
async function refreshSite(siteSlug: string) {
  try {
    const response = await fetch(
      `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/scrape-site`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          site_slug: siteSlug,
          trigger_source: 'manual'
        })
      }
    );

    const result = await response.json();

    // åˆ·æ–°æ•°æ®
    await loadRecords();
    await loadCookies();

    return result;
  } catch (error) {
    console.error('åˆ·æ–°å¤±è´¥:', error);
    throw error;
  }
}

// åˆ·æ–°æ‰€æœ‰ç½‘ç«™
async function refreshAll() {
  isRefreshing.value = true;

  try {
    const promises = sites.value.map(site => refreshSite(site.slug));
    await Promise.allSettled(promises);
  } finally {
    isRefreshing.value = false;
  }
}
</script>

<style scoped>
.monitor-view {
  min-height: 100vh;
  padding: 40px 20px;
  background: linear-gradient(
    -45deg,
    rgba(139, 92, 246, 0.05),
    rgba(59, 130, 246, 0.05),
    rgba(16, 185, 129, 0.05),
    rgba(236, 72, 153, 0.05)
  );
  background-size: 400% 400%;
  animation: gradient 15s ease infinite;
}

@keyframes gradient {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

.monitor-header {
  max-width: 1200px;
  margin: 0 auto 40px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.monitor-header h1 {
  font-size: 32px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.95);
}

.refresh-all-btn {
  padding: 12px 24px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  color: rgba(255, 255, 255, 0.9);
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.refresh-all-btn:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.15);
  transform: translateY(-2px);
}

.refresh-all-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.monitor-grid {
  max-width: 1200px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 24px;
}

@media (max-width: 768px) {
  .monitor-grid {
    grid-template-columns: 1fr;
  }
}
</style>
```

### 2. MonitorCard.vue

```vue
<template>
  <div class="monitor-card">
    <!-- å¡ç‰‡å¤´éƒ¨ -->
    <div class="card-header">
      <img :src="site.icon_url" :alt="site.name" class="site-icon" />
      <h3>{{ site.name }}</h3>
      <div 
        class="cookie-status" 
        :class="{ valid: cookieStatus?.is_valid, invalid: !cookieStatus?.is_valid }"
        :title="cookieTooltip"
      ></div>
    </div>

    <!-- å¡ç‰‡å†…å®¹ -->
    <div class="card-body">
      <div v-if="latestRecord && latestRecord.status === 'success'">
        <div 
          v-for="(value, key) in displayData" 
          :key="key" 
          class="data-row"
        >
          <span class="label">{{ formatLabel(key) }}:</span>
          <span class="value">{{ formatValue(value) }}</span>
        </div>
      </div>
      <div v-else-if="latestRecord && latestRecord.status === 'failed'" class="error-message">
        âŒ æŠ“å–å¤±è´¥: {{ latestRecord.error_message }}
      </div>
      <div v-else class="no-data">
        æš‚æ— æ•°æ®ï¼Œç‚¹å‡»åˆ·æ–°æŒ‰é’®è·å–
      </div>
    </div>

    <!-- å¡ç‰‡åº•éƒ¨ -->
    <div class="card-footer">
      <img 
        v-if="latestRecord?.screenshot_url" 
        :src="latestRecord.screenshot_url" 
        class="screenshot-thumb"
        @click="showScreenshot"
      />
      <span class="timestamp">
        {{ formatTime(latestRecord?.created_at) }}
      </span>
      <button 
        @click="handleRefresh" 
        :disabled="isRefreshing"
        class="refresh-btn"
      >
        {{ isRefreshing ? 'â³' : 'ğŸ”„' }}
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { formatDistanceToNow } from 'date-fns';
import { zhCN } from 'date-fns/locale';

const props = defineProps<{
  site: any;
  latestRecord: any;
  cookieStatus: any;
}>();

const emit = defineEmits<{
  refresh: [];
}>();

const isRefreshing = ref(false);

// æ˜¾ç¤ºæ•°æ®ï¼ˆè¿‡æ»¤æ‰ä¸éœ€è¦æ˜¾ç¤ºçš„å­—æ®µï¼‰
const displayData = computed(() => {
  if (!props.latestRecord?.data) return {};
  const { scraped_at, ...rest } = props.latestRecord.data;
  return rest;
});

// Cookieæç¤ºæ–‡æœ¬
const cookieTooltip = computed(() => {
  if (props.cookieStatus?.is_valid) {
    return `Cookieæœ‰æ•ˆ (æœ€åéªŒè¯: ${formatTime(props.cookieStatus.last_validated_at)})`;
  } else {
    return `Cookieå·²å¤±æ•ˆï¼Œéœ€è¦æ›´æ–°`;
  }
});

// æ ¼å¼åŒ–æ ‡ç­¾
function formatLabel(key: string): string {
  const labels: Record<string, string> = {
    credits: 'Creditsä½™é¢',
    balance: 'è´¦æˆ·ä½™é¢',
    free_credit: 'å…è´¹é¢åº¦',
    api_requests_today: 'ä»Šæ—¥APIè¯·æ±‚',
    daily_cost: 'ä»Šæ—¥æ¶ˆè´¹',
    included_usage: 'é…é¢ä½¿ç”¨',
    on_demand_usage: 'On-Demandæ¶ˆè´¹'
  };
  return labels[key] || key;
}

// æ ¼å¼åŒ–å€¼
function formatValue(value: any): string {
  if (value === null || value === undefined) return '-';
  
  if (typeof value === 'number') {
    return `$${value.toFixed(2)}`;
  }
  
  if (typeof value === 'object') {
    if (value.used !== undefined && value.total !== undefined) {
      const percentage = ((value.used / value.total) * 100).toFixed(1);
      return `${value.used} / ${value.total} (${percentage}%)`;
    }
    if (value.spent !== undefined && value.limit !== undefined) {
      const percentage = ((value.spent / value.limit) * 100).toFixed(1);
      return `$${value.spent} / $${value.limit} (${percentage}%)`;
    }
  }
  
  return String(value);
}

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(dateString: string | null): string {
  if (!dateString) return 'æœªçŸ¥';
  
  try {
    return formatDistanceToNow(new Date(dateString), {
      addSuffix: true,
      locale: zhCN
    });
  } catch {
    return 'æœªçŸ¥';
  }
}

// å¤„ç†åˆ·æ–°
async function handleRefresh() {
  isRefreshing.value = true;
  try {
    emit('refresh');
    // å»¶è¿Ÿ1ç§’å†é‡ç½®çŠ¶æ€ï¼Œé˜²æ­¢å¿«é€Ÿå¤šæ¬¡ç‚¹å‡»
    await new Promise(resolve => setTimeout(resolve, 1000));
  } finally {
    isRefreshing.value = false;
  }
}

// æ˜¾ç¤ºæˆªå›¾
function showScreenshot() {
  // TODO: å®ç°Modalæ˜¾ç¤ºå¤§å›¾
  window.open(props.latestRecord.screenshot_url, '_blank');
}
</script>

<style scoped>
.monitor-card {
  background: rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 24px;
  padding: 24px;
  box-shadow: 
    0 8px 32px 0 rgba(0, 0, 0, 0.1),
    inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.monitor-card:hover {
  background: rgba(255, 255, 255, 0.12);
  transform: translateY(-4px);
  box-shadow: 
    0 16px 48px 0 rgba(0, 0, 0, 0.15),
    inset 0 1px 0 0 rgba(255, 255, 255, 0.3);
}

.card-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
}

.site-icon {
  width: 32px;
  height: 32px;
  border-radius: 8px;
}

.card-header h3 {
  flex: 1;
  font-size: 18px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.95);
}

.cookie-status {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.cookie-status.valid {
  background: rgba(52, 211, 153, 0.9);
  box-shadow: 
    0 0 10px rgba(52, 211, 153, 0.5),
    0 0 20px rgba(52, 211, 153, 0.3);
}

.cookie-status.invalid {
  background: rgba(248, 113, 113, 0.9);
  box-shadow: 
    0 0 10px rgba(248, 113, 113, 0.5),
    0 0 20px rgba(248, 113, 113, 0.3);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.card-body {
  min-height: 120px;
  margin-bottom: 16px;
}

.data-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.data-row:last-child {
  border-bottom: none;
}

.label {
  color: rgba(255, 255, 255, 0.7);
  font-size: 14px;
}

.value {
  color: rgba(255, 255, 255, 0.95);
  font-weight: 600;
  font-size: 14px;
}

.error-message,
.no-data {
  color: rgba(255, 255, 255, 0.6);
  font-size: 14px;
  text-align: center;
  padding: 32px 0;
}

.card-footer {
  display: flex;
  align-items: center;
  gap: 12px;
  padding-top: 16px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.screenshot-thumb {
  width: 40px;
  height: 40px;
  object-fit: cover;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s;
}

.screenshot-thumb:hover {
  transform: scale(1.1);
}

.timestamp {
  flex: 1;
  color: rgba(255, 255, 255, 0.6);
  font-size: 12px;
}

.refresh-btn {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s;
}

.refresh-btn:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.2);
  transform: rotate(90deg);
}

.refresh-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</style>
```

## ç¯å¢ƒå˜é‡é…ç½®

### .envæ–‡ä»¶

```env
# Supabaseé…ç½®
VITE_SUPABASE_URL=https://ojbocxqvufoblihkzijn.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key-here
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here

# Vercel Cronå¯†é’¥
CRON_SECRET=generate-a-random-secret-here

# å¯é€‰ï¼šå…¶ä»–é…ç½®
NODE_ENV=production
```

## éƒ¨ç½²å‘½ä»¤

```bash
# éƒ¨ç½²Edge Functions
cd supabase
supabase functions deploy scrape-site
supabase functions deploy scrape-all

# éƒ¨ç½²å‰ç«¯åˆ°Vercel
vercel deploy --prod

# æœ¬åœ°æµ‹è¯•Edge Function
supabase functions serve scrape-site --no-verify-jwt
```

